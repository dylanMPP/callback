# **Structural Induction**

## **Number of Inversions (Problem #1) - MergeSort**

### **BASE CASE:** 
To complete this step, we need to show that $mergeSort(list)$ where $list.length = k$ and $k \leq 1$, yields the ascending sorted list $list$ and the number of inversions needed to sort it. Indeed, the algorithm gives us the expected result, since when executed, enter evaluates the first $if$ and enters there, since $k\leq1$, thus returning the same list without modifications, because it is ordered ascending and has a number of investments $=0$

### **INDUCTIVE STEP:** 
We assume that the algorithm $mergeSort(list)$ where $list.length=n$ and $n>1$ works correctly, that is, it gives us the ascending sorted list and the number of reversals needed. By H.I (inductive hypothesis) we know that with $mergeSort(list2)$, where $list2.length=n+1$, the algorithm in the first execution enters $else$ last, where it splits the list in half $(\frac {n+1}{2})$ into two sublists: $(left, right)$. After this: on the one hand, it calls itself with $left$ as a parameter, obtaining as a result this ascending ordered list and the number of necessary inversions; otherwise, it calls itself with $right$ as a parameter, returning this ascending-ordered list and the number of inversions required. We can note that $left.length < n$ and that $right.length < n$, so, having already assumed that the algorithm works correctly for a list whose length is $n$, obviously it will work for these two sublists as well. successfully, returning the expected result. Now, looking at it further, the $mergeSort(...)$ function calls the $merge(List[Int], List[Int], Int)$ function, which merges both lists that are passed to it as a parameter and has the following conditions to order the elements of the lists, and that we will assume as correct and that returns the expected result. Recursive calls with $left$ and $right$ as parameters of $mergeSort$ will execute and keep calling $mergeSort$ recursively until, by the halving, they fall into the base case and return the same list and $0 $ as inversions, then the call to $merge$ will be executed sequentially to compare the elements of the lists and merge them, after all the recursive calls to $mergeSort(left)$ and to $mergeSort(right)$ have been executed, $merge(left, right, 0)$ will be called to join the lists depending on the order and return a specific number of investments, finally, we return the list resulting from $merge$ (already joined and ordered ascending) and the number of inversions that were necessary for $left$, for $right$ and for their union.

## **Improved Quicksort (Problem #2) - ImprovingQuickSort**

### **BASE CASE:** 
To complete this step, we need to show that $improvingQuickSort(list)$ where $list.length = k$ and $k \leq 1$ produces the ascending sorted list $list$. Indeed, the algorithm gives us the expected result, since when executed, it enters evaluates the pattern matching cases ($match$) and enters the first or second case ($k=0$ or $k=1$), thus returning the Same list without changes, because it is ordered ascending.

### **INDUCTIVE STEP:** 
We assume that the algorithm $improvingQuickSort(list)$ where $list.length=n$ and $n>1$ works correctly, that is, it gives us the ascending sorted list. By H.I (inductive hypothesis) we know that with $improvingQuickSort(list2)$, where $list2.length=n+1$, the algorithm in the first execution enters last case ($head::tail$), where it selects the two pivots randomly with the function $random(Int, Int)$ (which we will assume is correct and which returns the expected result), selects the two pivots of the list and places them at the beginning of the list, creating an auxiliary list ($exchangedList$), to then compare the pivots to find which is larger and which is smaller (or if both are equal) and calls the $randomized3WayPartition(List[Int], Int, Int, List[Int] , List[Int], List[Int])$, which we will assume to be correct and which returns the expected result and which returns the list passed as a parameter divided into three: $(left, center, right)$, already sorted, since it compares each element of the auxiliary list (list without the pivots) with the pivots, placing those that are less than or equal to pivot $1$ in the list $left$, those that are greater than or equal to pivot $1$ but less than or equal to pivot $2$ in the $center$ list and those that are greater than pivot $2$ in the $right$ list. Then, we make three recursive calls to $improvingQuickSort$, one for each partition obtained, and there we can note that $left.length < n+1$, $center.length < n+1$ and that $right.length < n+ 1$, so, having already assumed that the algorithm works correctly for a list whose length is $n$, obviously for these three sublists it will also work correctly, returning the expected result. Now, after these recursive calls, we will join (with the operator $:::$ and the operator $::$) the list $left$, $center$ and $right$ and to the pivots (we will place one before the other depending on whichever is smaller or larger), in order to obtain the resulting total list already sorted.


## **Closest Points (Problem #3) - FindMinDistance**

### **BASE CASE:** 
To complete this step, we need to show that $findMinDistance(list, min)$ where $list =$ list of pairs of points, $list.length = k$ and $min = Int.MaxValue$, gives us the minimum distance (distance Euclidean) existing between two pairs of different pairs of points. Indeed, the algorithm gives us the expected result, since when executed, it evaluates the pattern matching cases ($match$) and enters the first case ($k=0$), thus returning the variable $min$, which, in At that moment, it will be equal to $Int.MaxValue$, giving a result that the input is invalid, since from an empty list we cannot calculate a minimum distance between a pair of pairs of points. It should be noted that the base case when $k=1$ is not present in the function, since in the algorithm, in a function that is executed before this one, this base case is already validated and, in addition, the result provided by the function for $k=1$ it is needed in the $closestPoints(...)$ algorithm later.

### **INDUCTIVE STEP:** 
We assume that the algorithm $findMinDistance(list, min)$ where $list.length=n$ and $n\geq1$ works correctly, that is, it returns the minimum distance (Euclidean distance) existing between two pairs of different pairs of points . By H.I (inductive hypothesis) we know that with $findMinDistance(list2, min)$, where $list2.length=n+1$, the algorithm in the first execution enters last case ($head::tail$), where it obtains the minimum distance between a pair of pairs of different points with the function $parallelForsMinDistance(List[Int], List[List[Int]], List[Int])$, which we will assume is correct and returns the expected result, and to the that we pass the $head$ and $tail$ of the list as parameters, in order to find the distance between each pair of different points and return the minimum. After this, it goes on to check if this minimum distance found is less than the variable $min$, if it IS, then it calls $findMinDistance(...)$ recursively passing it as parameters the $tail$ of the original list ( since we already used the $head$ to find the minimum distance) and $min$, which was updated by the minimum distance found in that iteration; if it is NOT, then it calls $findMinDistance(...)$ recursively passing it as parameters the $tail$ of the original list (since we already used the $head$ to find the minimum distance) and $min$, which is NOT was updated, since the minimum distance found in that iteration was not lower. Thus, we can notice that in this new recursive call the list has a shorter length by one unit (we remove the $head$) as $list2.length= n$, therefore, having already assumed that the algorithm works correctly for a list whose length is $n$, obviously for this updated list it will also work correctly, returning the expected result. Now, these recursive calls will be made over and over again until the list is $Nil$ (base case), which is when it returns $min$, which may or may not have been updated before and returns the minimum distance found between a pair of pairs of different points (in case they are all the same, it returns $Int.MaxValue$, since it was never updated).